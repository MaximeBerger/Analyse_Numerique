<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[ESTP]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>ESTP</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 23 May 2025 06:32:19 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 23 May 2025 06:32:16 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[C'est quoi l'Analyse numérique ?]]></title><description><![CDATA[ 
 <br>La version interactive de ce cours est disponible sur <a data-tooltip-position="top" aria-label="https://maximeberger.github.io/Analyse_Numerique/enseignement/4-analyse-num%C3%A9rique/cm-1-introduction.html" rel="noopener nofollow" class="external-link" href="https://maximeberger.github.io/Analyse_Numerique/enseignement/4-analyse-num%C3%A9rique/cm-1-introduction.html" target="_blank">ce lien</a><br><br>Au carrefour entre Maths, Ingénierie et Informatique : <br>
<br>Modéliser des problèmes physiques
<br>Traduire le problème en équation
<br>L'ordinateur les résout
<br>Equations difficiles -&gt;  Il y aura plusieurs façons de faire !<br><br><br><br><img alt="Capture d’écran 2025-02-03 à 14.20.25.png" src="lib/media/capture-d’écran-2025-02-03-à-14.20.25.png"><br><br>Equation d'équilibre de la structure :<br>
avec <br>
<br> le déplacement transversal au point 
<br> le module d'Young (plus  est grand, plus le matériau est rigide)
<br> la force exercée
<br> le moment d'inertie qui peut dépendre de  ( caractérise la résistance à la flexion autour du point )
<br><br>On reviendra sur cet exemple au CM 5, avec la méthode des différences finies. <br>Simplifions : le moment d'inertie  est constant le long de la poutre, on obtient<br>
avec   <br><img alt="Capture d’écran 2025-02-03 à 14.20.49.png" src="lib/media/capture-d’écran-2025-02-03-à-14.20.49.png"><br><br>Phénomène de Flambage:<br>
<br>Un mur porteur dans un bâtiment
<br>une plaque géologique soumise à des pressions crée des montagnes
<br>Une roue de vélo
<br>Des rails de train qui se dilatent sous l'effet de la chaleur
<br><br><br>5 CM : <br>
<br>Introduction
<br>Approximation polynomiale
<br>Intégration numérique
<br>Analyse numérique matricielle 
<br>Résolution d'équations différentielles
<br><br>Des TD et des TP en Python ! <br><br>C'est un domaine difficile ! On fait des erreurs :  <br>
<br>dans le modèle, 
<br>(dans les calculs pour obtenir les équations)
<br>quand on travaille sur l'ordinateur ! 
<br>dans les méthodes qui donnent une solution
<br><br>math.sqrt(2)**2 
   &gt; 2.0000000000000004
<br>Comment est représenté un nombre à virgules  ?<br>
<br>Type float : sur 32 bits, des nombres entre  et  avec  chiffres significatifs après la virgule. 
<br>Type double : sur 64 bits, des nombres entre  et  avec  chiffres significatifs après la virgule. 
<br><br><br>Si  est une valeur approchée de , l'erreur absolue est<br>
<br>
Quelle est l'erreur absolue quand on approche  par  ?<br>

<br><img alt="Capture d’écran 2025-02-02 à 17.40.33.png" src="lib/media/capture-d’écran-2025-02-02-à-17.40.33.png"><br><br><br><br>Se calcule par le rapport de l'erreur absolue sur la valeur exacte :<br>
Si on ne connait pas , on peut l'estimer en calculant plutôt:<br>
<br><br>Quand on écrit le résultat d'un calcul, il faut faire attention aux chiffres significatifs employés.<br>Le nombre 100 par exemple, peut représenter les valeurs arrondies des nombres <br>
<br>
<br>
<br><br>
...<br>
Tous les nombres entre  et  exclus seront arrondis par <br>
<img alt="Capture d’écran 2025-02-03 à 13.43.04.png" src="lib/media/capture-d’écran-2025-02-03-à-13.43.04.png">
<br><img alt="Capture d’écran 2025-02-03 à 13.44.56.png" src="lib/media/capture-d’écran-2025-02-03-à-13.44.56.png" style="width: 500px; max-width: 100%;"><br><img alt="Capture d’écran 2025-02-03 à 14.22.47.png" src="lib/media/capture-d’écran-2025-02-03-à-14.22.47.png"><br><br>Quand on fait une somme:<br>
<br>Quand on fait un produit<br>
<br>Quand on applique une fonction<br>
<br><br><br><br>Pour résoudre des équations de type <br>On peut partir d'une valeur  et appliquer la suite récurrente<br>
<br>Théorème :<br>
Pour une fonction  telle que , (on dit que  est contractante)<br>
Alors  admet un unique point fixe, et toute suite récurrente  converge vers ce point fixe.<br>On peut appliquer le théorème:<br>import numpy as np
import matplotlib.pyplot as plt

x0 = 0.5  
iterations = 50

def iterative_process(x0, iterations):
    x_exact = np.zeros(iterations)
    
    x_exact[0] = x0
    
    for i in range(1, iterations):
        x_exact[i] = np.cos(x_exact[i-1])
    
    return x_exact

x = iterative_process(x0, iterations)

plt.plot(x)
<br>C'est une méthode itérative, l'étape  se sert des résultats de l'étape . <br>Cela peut poser des problèmes si des erreurs se cumulent ! <br>def iterative_process(x0, iterations):
    x_exact = np.zeros(iterations)
    x_approx = np.zeros(iterations)
    
    x_exact[0] = x0
    x_approx[0] = x0 + 1e-10 
    
    for i in range(1, iterations):
        x_exact[i] = 30*np.cos(x_exact[i-1])
        x_approx[i] = 30*np.cos(x_approx[i-1])
    
    return x_exact, x_approx

x0 = 0.2  
iterations = 50 

x_exact, x_approx = iterative_process(x0, iterations)

differences = np.abs(x_exact - x_approx)

plt.semilogy(differences, label="Erreur d'approximation")
<br><br>Si on connait un intervalle  dans lequel l'équation admet une unique solution. <br>Pour trouver une solution à l'équation . On sait qu'une seule solution se situe dans l'intervalle :<br>
<br>On calcule le milieu de l'intervalle : 
<br>On regarde l'équation au point , la solution se situe-t-elle avant ou après  ?<br>
- Si la solution est avant , on recommence avec le nouvel intervalle <br>
- Si la solution est après , on recommence avec le nouvel intervalle <br>
On continue jusqu'à atteindre la précision souhaitée
<br><img alt="Capture d’écran 2025-02-03 à 14.21.23.png" src="lib/media/capture-d’écran-2025-02-03-à-14.21.23.png"><br>import math

def dichotomie(a, b, epsilon=1e-6):

	while (b - a) / 2 &gt; epsilon:
		c = (a + b) / 2
        
		if c &gt; math.cos(c):
			b = c
		else:
			a = c
    
	return (a + b) / 2 

print(dichotomie(0.1, 1))
<br><br>On fait comme si la fonction  est une droite:<br>
<br>On choisit un point , pas trop loin de la solution, 
<br>On calcule la dérivée en ce point 
<br>On pose 
<br>Si l'équation est une droite passant en , et de pente ,  est la solution de l'équation . 
<br>On recommence avec . 
<br>import math
x0 = 0.5

def f(x):
    return x - math.cos(x)

def df(x):
    return 1 + math.sin(x)

def newton(x0, epsilon=1e-6):
    x = x0
    iter_count = 0
    
    while abs(f(x)) &gt; epsilon:
        x = x - f(x) / df(x) 
        
    return x

print(newton(x0))
<br><img alt="Capture d’écran 2025-02-03 à 14.21.49.png" src="lib/media/capture-d’écran-2025-02-03-à-14.21.49.png"><br><br>Comment l'ordinateur calcule la valeur de  ? ]]></description><link>enseignement/4-analyse-numérique/cm-1-introduction.html</link><guid isPermaLink="false">Enseignement/4 - Analyse Numérique/CM 1 - Introduction.md</guid><pubDate>Thu, 06 Feb 2025 15:08:38 GMT</pubDate><enclosure url="lib/media/capture-d’écran-2025-02-03-à-14.20.25.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/capture-d’écran-2025-02-03-à-14.20.25.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Les seules fonctions calculables]]></title><description><![CDATA[ 
 <br>La version interactive de ce cours est disponible sur <a data-tooltip-position="top" aria-label="https://maximeberger.github.io/Analyse_Numerique/enseignement/4-analyse-num%C3%A9rique/cm2-approximation-polynomiale.html" rel="noopener nofollow" class="external-link" href="https://maximeberger.github.io/Analyse_Numerique/enseignement/4-analyse-num%C3%A9rique/cm2-approximation-polynomiale.html" target="_blank">ce lien</a><br><br>Un ordinateur/calculatrice peut seulement effectuer les 4 opérations<br>
<br>Quelles fonctions peut-on calculer ?<br>
<img alt="Capture d’écran 2025-02-17 à 11.09.30.png" src="lib/media/capture-d’écran-2025-02-17-à-11.09.30.png"><br>Question : Comment calculer<br>
<br>Des racines carrées ? 
<br>Des exponentielles   ?
<br>Des cosinus  ? 
<br>Des intégrales ? (-&gt; CM 3)
<br>Des solutions d'équations différentielles  ? (-&gt; CM 5)
<br><br>Comment calculer   à la main ? <br>
<br>Par interpolation : 
<br><br>Il faut en fait chercher le zéro de la fonction<br>
<img alt="Capture d’écran 2025-02-17 à 11.09.49.png" src="lib/media/capture-d’écran-2025-02-17-à-11.09.49.png"><br>
<br>
Par dichotomie

<br>On sait que c'est entre 4 et 5
<br>On essaye 4.5  la racine se trouve entre 4.5 et 5
<br>On essaye 4.75 ... 


<br>
Par méthode de Newton<br>
Fonctionne encore mieux avec<br>
La fonction ressemble plus à une fonction affine. 

<br><br>Il y a plusieurs façons de multiplier de grands nombres avec  chiffres ! Il y a plusieurs façons de multiplier de grands nombres avec  chiffres !<br>
(wooclap)<br><br>Ce n'est pas la seule (ni la meilleure) façon de faire !<br>Quelques idées : <br>
<br>Karatsuba On divise les nombres en deux parties

On a donc :
<br><br>Ce qui donne après développement :<br><br>On se ramène à des multiplications plus petites. <br>
<br>
Tom-Cook On divise en plus que 2 parties.<br>
Chaque nombre est vu comme la valeur d'un polynôme en un point avec des coefficients simples. 


On évalue ces polynômes en différents points pour retrouver le polynôme produit. 

<br>
Schönhage-Strassen, Harvey-Van der Hoeven utilisent la transformée de Fourier en arithmétique modulaire.<br>
Travaillent modulo <br>
Transformée de Fourier transforme le produit en convolution

<br><br><img alt="Capture d’écran 2025-02-17 à 11.12.41.png" src="lib/media/capture-d’écran-2025-02-17-à-11.12.41.png"><br>
Les mathématiques montrent que la limite théorique est <br><br>Exponentielle ne peut pas s'écrire comme racine d'un polynôme.<br>But :   est compliquée, longue à calculer. On la remplace par une approximation  plus simple. <br>
<br>Dans quelle catégorie de fonction allons-nous choisir  ? 
<br><img alt="Capture d’écran 2025-02-17 à 11.12.53.png" src="lib/media/capture-d’écran-2025-02-17-à-11.12.53.png"><br>
<br>Quels critères diront si  est une bonne approximation ou non ?<br>
<img alt="Capture d’écran 2025-02-17 à 11.13.12.png" src="lib/media/capture-d’écran-2025-02-17-à-11.13.12.png">
<br>Normes<br>
<br>Sur quel intervalle  est-elle une bonne approximation ? 
<br><br>Ces algorithmes sont tous implémentés dans les ordinateurs d'aujourd'hui, pourquoi les apprendre ? <br>
<br>Vous êtes dans un contexte d'apprentissage.  C'est un problème jouet. 
<br>Découvrir le "bon" algorithme est une compétence qui vous servira dans d'autres contextes. 
<br>Comprendre pourquoi certains algorithmes sont meilleurs que d'autres. 
<br><br><br>Combien d'opérations cela prend de calculer la valeur de  ? <br><img alt="Capture d’écran 2025-02-17 à 11.13.25.png" src="lib/media/capture-d’écran-2025-02-17-à-11.13.25.png"><br>Un algorithme plus économe : Algorithme de Horner<br>
On écrit plutôt : <br><br><img alt="Capture d’écran 2025-02-17 à 11.13.45.png" src="lib/media/capture-d’écran-2025-02-17-à-11.13.45.png"><br>Une analogie pour calculer  avec degré  <br><img alt="Capture d’écran 2025-02-17 à 11.14.23.png" src="lib/media/capture-d’écran-2025-02-17-à-11.14.23.png"><br><br>Théorème de Weierstrass : <br>Pour toute fonction continue ,<br>
Pour toute précision  fixée,<br>
Il existe un polynôme  tel que<br>
<br>Problème : on n'a aucun moyen de calculer ce polynôme ! <br><br>Pour approcher une fonction autour d'un point par un polynôme :<br>
Théorème de Taylor :<br>
<br><br>
<br>
Combien de termes faut-il prendre ?  -&gt; Erreur de Troncation

<br>
En quel point prendre ce DL ? 

<br>Exemple : La fonction  sur l'intervalle  approchée par son DL en 0.<br>
<br><img alt="Valeurs des termes $u_k$ de la série de $e^{-10}$ pour $k=0$ à $25$.png" src="lib/media/valeurs-des-termes-$u_k$-de-la-série-de-$e^{-10}$-pour-$k=0$-à-$25$.png"><br>A la main, , <br>
<br>Pour avoir une précision relative de  il faut que le premier terme qu'on ne prenne pas soit d'ordre , il faut sommer au moins les  premiers termes.<br>
et il faut calculer tous ces termes avec une précision de <br>
 12 chiffres significatifs pour  <br><img alt="Capture d’écran 2025-02-17 à 11.14.39.png" src="lib/media/capture-d’écran-2025-02-17-à-11.14.39.png"><br>
D'ailleurs, comment calculer   ?<br>
V<br>On calcule progressivement les termes en utilisant<br>
<img alt="Capture d’écran 2025-02-17 à 11.14.49.png" src="lib/media/capture-d’écran-2025-02-17-à-11.14.49.png"><br>
<br>
C'est une méthode possible pour calculer les valeurs proches de 0 

<br>
Si loin de zéro, on peut utiliser une propriété de l'exponentielle :<br>
- Décomposer un nombre  en<br>
 avec  un nombre entier. On peut alors écrire :<br>


<br><br>Pour calculer les valeurs de la fonction exponentielle, on cherche la meilleure fraction rationnelle. <br>Approximant de Padé<br>Pour la fonction exponentielle, on utilise souvent :<br>
Voir en TD. <br><br>Remplacer  par une fonction simple  qui coïncide avec les valeurs de  en certains points. <br>interpolation : On part de certaines valeurs de  et on "interpole" : on essaye de relier ces points entre eux. <br>Vous l'avez souvent fait en TP chimie<br>
<br>Mesurer la température d'une poutre en différents endroits
<br>La concentration d'une certaine molécule en différents endroits. 
<br>La conductivité d'une solution en différents instants de temps
<br><img alt="Capture d’écran 2025-02-17 à 11.15.11.png" src="lib/media/capture-d’écran-2025-02-17-à-11.15.11.png"><br><br><br>Relier les points par des segments de droite, calcul très rapide !<br>
C'est ce qui est fait dans les processeurs actuels, stockent 1024 valeurs de la fonction exponentielle entre  puis interpolent de façon linéaire<br><img alt="Capture d’écran 2025-02-17 à 11.15.26.png" src="lib/media/capture-d’écran-2025-02-17-à-11.15.26.png"><br><br>Pour calculer la valeur en , on prend les  points les plus proches dans la table, et on trouve la meilleure parabole qui passe par ces  points. <br>Mais comment calculer cette parabole ? <br><img alt="Capture d’écran 2025-02-17 à 11.15.36.png" src="lib/media/capture-d’écran-2025-02-17-à-11.15.36.png"><br><br>Dans toute cette section on cherche les coefficients d'un polynôme <br>
Le problème est de régler  et  pour que   passe par certains points fixés<br>
<br><br>Quel degré pour  ? <br><img alt="Capture d’écran 2025-02-17 à 11.15.45.png" src="lib/media/capture-d’écran-2025-02-17-à-11.15.45.png"><br><br>Quel degré pour  ? <br>Degré 1 suffit <br><img alt="Capture d’écran 2025-02-17 à 11.16.06.png" src="lib/media/capture-d’écran-2025-02-17-à-11.16.06.png"><br><br>Quel degré pour   ? <br>Degré 2 suffit <br><br>Quel degré pour  ?  <br><br>A la force brute :<br>
<img alt="Capture d’écran 2025-02-17 à 11.16.30.png" src="lib/media/capture-d’écran-2025-02-17-à-11.16.30.png"><br>
C'est compliqué. <br>Une autre idée : On va trouver des polynômes  tels que <br>
<br> vaut 1 en 
<br> vaut 0 en 
<br> vaut  en 
<br>...
<br><img alt="Capture d’écran 2025-02-17 à 11.16.57.png" src="lib/media/capture-d’écran-2025-02-17-à-11.16.57.png"><br>  est de degré <br>
   est multiple de <br>
 donc <br>
 Que vaut  ?<br><img alt="Capture d’écran 2025-02-17 à 11.17.05.png" src="lib/media/capture-d’écran-2025-02-17-à-11.17.05.png"><br>
Ainsi <br><br>On peut l'écrire aussi<br>
<br><br>
<br> vaut  en 
<br> vaut  en 
<br> vaut  en 
<br>...<br>

<br>On construit alors<br>
et  convient <br><img alt="Capture d’écran 2025-02-17 à 11.17.16.png" src="lib/media/capture-d’écran-2025-02-17-à-11.17.16.png">]]></description><link>enseignement/4-analyse-numérique/cm2-approximation-polynomiale.html</link><guid isPermaLink="false">Enseignement/4 - Analyse Numérique/CM2 - Approximation Polynomiale.md</guid><pubDate>Thu, 24 Apr 2025 07:11:58 GMT</pubDate><enclosure url="lib/media/capture-d’écran-2025-02-17-à-11.09.30.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/capture-d’écran-2025-02-17-à-11.09.30.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Retour sur l'Interpolation de Lagrange]]></title><description><![CDATA[ 
 <br>La version interactive de ce cours est disponible sur <a data-tooltip-position="top" aria-label="https://maximeberger.github.io/Analyse_Numerique/enseignement/4-analyse-num%C3%A9rique/cm3-d%C3%A9rivation-et-int%C3%A9gration-num%C3%A9rique.html" rel="noopener nofollow" class="external-link" href="https://maximeberger.github.io/Analyse_Numerique/enseignement/4-analyse-num%C3%A9rique/cm3-d%C3%A9rivation-et-int%C3%A9gration-num%C3%A9rique.html" target="_blank">ce lien</a><br><br><img alt="Lagrange_portrait.jpg" src="lib/media/lagrange_portrait.jpg"><br>Visualisation :<br>
<a rel="noopener nofollow" class="external-link" href="https://www.desmos.com/calculator/pzfyv9wpyg" target="_blank">https://www.desmos.com/calculator/pzfyv9wpyg</a><br>Phénomène de Runge :<br>Calculer le polynôme de Lagrange qui coïncide avec cette fonction aux points d'abscisses <br>
<img alt="Capture d’écran 2025-02-28 à 09.48.03.png" src="lib/media/capture-d’écran-2025-02-28-à-09.48.03.png"><br>
<img alt="Capture d’écran 2025-02-28 à 09.48.18.png" src="lib/media/capture-d’écran-2025-02-28-à-09.48.18.png"><br>
<img alt="Capture d’écran 2025-02-28 à 09.48.41.png" src="lib/media/capture-d’écran-2025-02-28-à-09.48.41.png"><br><br>Les polynômes divergent au bord de l'intervalle.<br>
<a rel="noopener nofollow" class="external-link" href="https://www.desmos.com/calculator/uwtrvznnjh" target="_blank">https://www.desmos.com/calculator/uwtrvznnjh</a><br>Comment faire ? <br>
<br>Changer la positions des points<br>
Toute une théorie impliquant polynômes orthogonaux, fonctions de poids.<br>
<img alt="Capture d’écran 2025-02-28 à 09.50.00.png" src="lib/media/capture-d’écran-2025-02-28-à-09.50.00.png">
<br>Découper l'intervalle en petits intervalles et calculer des polynômes de Lagrange degrés 1 ou 2 sur chaque intervalle. 

<br>Comment faire ce découpage ?<br>
<img alt="Capture d’écran 2025-02-28 à 09.50.11.png" src="lib/media/capture-d’écran-2025-02-28-à-09.50.11.png">


<br><br>Problème:  Comment calculer des intégrales ?<br>
<img alt="Capture d’écran 2025-02-28 à 09.50.31.png" src="lib/media/capture-d’écran-2025-02-28-à-09.50.31.png"><br><br>On fait comme si  est constante sur l'intervalle  <br>
<br>Faire un dessin 
<br>Quelle catégorie de fonctions donne des résultats exacts par cette méthode ?<br>
<img alt="Capture d’écran 2025-02-28 à 10.29.13.png" src="lib/media/capture-d’écran-2025-02-28-à-10.29.13.png"><br>
<img alt="Capture d’écran 2025-02-28 à 10.29.21.png" src="lib/media/capture-d’écran-2025-02-28-à-10.29.21.png">
<br><br>
<br>Découper en petits intervalles, 
<br>Approcher  par une constante sur chaque intervalle.
<br>
<br>Faire un dessin 
<br><img alt="Capture d’écran 2025-02-28 à 10.29.36.png" src="lib/media/capture-d’écran-2025-02-28-à-10.29.36.png"><br>
<br>Ecrivez le pseudo code d'une fonction qui calcule l'intégrale d'une fonction  donnée avec  la longueur de l'intervalle passé en paramètre. 
<br><img alt="Capture d’écran 2025-02-28 à 10.29.55.png" src="lib/media/capture-d’écran-2025-02-28-à-10.29.55.png"><br>
<img alt="Capture d’écran 2025-02-28 à 10.30.04.png" src="lib/media/capture-d’écran-2025-02-28-à-10.30.04.png"><br>
<img alt="Capture d’écran 2025-02-28 à 10.30.15.png" src="lib/media/capture-d’écran-2025-02-28-à-10.30.15.png"><br>
<img alt="Capture d’écran 2025-02-28 à 10.30.36.png" src="lib/media/capture-d’écran-2025-02-28-à-10.30.36.png"><br>
<img alt="Capture d’écran 2025-02-28 à 10.30.43.png" src="lib/media/capture-d’écran-2025-02-28-à-10.30.43.png"><br><img alt="Capture d’écran 2025-02-28 à 10.30.59.png" src="lib/media/capture-d’écran-2025-02-28-à-10.30.59.png"><br>
<img alt="Capture d’écran 2025-02-28 à 10.31.06.png" src="lib/media/capture-d’écran-2025-02-28-à-10.31.06.png"><br><br>Approcher  par une fonction  et approcher  par  <br><br>
<br>Si  est le polynôme de Lagrange de , que vaut  ?
<br><img alt="Capture d’écran 2025-02-28 à 10.31.28.png" src="lib/media/capture-d’écran-2025-02-28-à-10.31.28.png"><br>
On retrouve la première méthode ci-dessus. <br><br>Et pour un polynôme avec un degré plus grand ?<br>
<img alt="Capture d’écran 2025-02-28 à 10.31.55.png" src="lib/media/capture-d’écran-2025-02-28-à-10.31.55.png"><br>
<img alt="Capture d’écran 2025-02-28 à 10.32.17.png" src="lib/media/capture-d’écran-2025-02-28-à-10.32.17.png"><br>
<img alt="Capture d’écran 2025-02-28 à 10.32.32.png" src="lib/media/capture-d’écran-2025-02-28-à-10.32.32.png"><br>
<img alt="Capture d’écran 2025-02-28 à 10.32.58.png" src="lib/media/capture-d’écran-2025-02-28-à-10.32.58.png"><br><br><img alt="Capture d’écran 2025-02-28 à 10.33.11.png" src="lib/media/capture-d’écran-2025-02-28-à-10.33.11.png">]]></description><link>enseignement/4-analyse-numérique/cm3-dérivation-et-intégration-numérique.html</link><guid isPermaLink="false">Enseignement/4 - Analyse Numérique/CM3 - Dérivation et Intégration numérique.md</guid><pubDate>Fri, 28 Feb 2025 09:53:43 GMT</pubDate><enclosure url="lib/media/lagrange_portrait.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/lagrange_portrait.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Petit exo préliminaire]]></title><description><![CDATA[ 
 <br><br>Déterminer le polynôme de degré minimal qui coïncide avec la fonction  aux points d'abscisse  et  <br><br>
<br>Résoudre un système par pivot de Gauss
<br>Ecrire la décomposition LU d'une matrice
<br>Connaitre et écrire la méthode itérative de Jacobi et l'appliquer sur une matrice. 
<br><br>Les systèmes linéaires sont des problèmes du type :<br>
Trouver  qui vérifient : <br><br>Ces problèmes apparaissent dans des contextes très différents. <br>
<br>Résistance des matériaux, 

<br>Equation de type  avec 


<br>Résolution d'équations différentielles 

<br>Méthode des éléments finis, cours de 2A


<br>Calcul des modes de vibrations 

<br>Recherche d'éléments propres <br>
avec  la matrice de masse. 


<br>Des méthodes avec beaucoup d'opérations :  permettront de résoudre exactement.<br>
D'autres méthodes plus rapides permettront d'obtenir des solutions approchées. <br><br><br>Combien d'opérations coûtent un calcul de déterminant ? <br><br>On va modifier le système pour le ramener à un système triangulaire :<br>
<br>Premiers "pivots" :<br>
<br>Ces nombres vont nous servir à éliminer l'inconnue  de toutes les lignes de la matrice sauf la première. <br>
<br>On remplace la deuxième ligne par  : 
<br><br><br>Les solutions du système sont très sensibles aux erreurs d'arrondis ! <br>]]></description><link>enseignement/4-analyse-numérique/cm4-analyse-numérique-matricielle.html</link><guid isPermaLink="false">Enseignement/4 - Analyse Numérique/CM4 - Analyse numérique matricielle.md</guid><pubDate>Wed, 19 Mar 2025 20:32:30 GMT</pubDate></item><item><title><![CDATA[CM5 - Résolution numérique d'équations différentielles]]></title><description><![CDATA[ 
 ]]></description><link>enseignement/4-analyse-numérique/cm5-résolution-numérique-d&apos;équations-différentielles.html</link><guid isPermaLink="false">Enseignement/4 - Analyse Numérique/CM5 - Résolution numérique d&apos;équations différentielles.md</guid><pubDate>Tue, 04 Feb 2025 08:46:33 GMT</pubDate></item><item><title><![CDATA[Consignes]]></title><description><![CDATA[ 
 <br>La version interactive de ce TP se trouve ici :<br>
<a data-tooltip-position="top" aria-label="https://maximeberger.github.io/Analyse_Numerique/enseignement/4-analyse-num%C3%A9rique/tp-1-analyse-num%C3%A9rique.html" rel="noopener nofollow" class="external-link" href="https://maximeberger.github.io/Analyse_Numerique/enseignement/4-analyse-num%C3%A9rique/tp-1-analyse-num%C3%A9rique.html" target="_blank">ce lien</a><br>
Cette version interactive vous permettra de copier-coller le python plus facilement !<br>Point fixe, Dichotomie, Newton, Interpolation polynomiale, Calcul approché d'intégrales. <br><br>Intelligence artificielle interdite dans votre rendu final. <br>
<br>Soupçons -&gt; Division de la note par 2
<br>Certitude -&gt; 0/20
<br>Vous pouvez vous en servir pour demander des exemples simples ou poser des questions. 
<br>Vous rendrez un rapport de TP avec <br>
<br>les réponses aux questions, 
<br>les parties de code que vous avez modifiées ou écrites en les expliquant, 
<br>les graphes que vous avez tracés.<br>
Vous reprendrez la structure de ce sujet avec les titres et les sous-titres. 
<br>Vous pouvez travailler seul ou par binôme.<br>
Vous rendrez votre rapport en format pdf, avec les noms des membres du binôme dans le nom du fichier avant le 4 Mai 23h59 en déposant votre fichier sur ce lien :<br>
<a data-tooltip-position="top" aria-label="https://www.dropbox.com/request/rUe4FWuRQkdGPKSVUmD0" rel="noopener nofollow" class="external-link" href="https://www.dropbox.com/request/rUe4FWuRQkdGPKSVUmD0" target="_blank">Dépôt TP1</a><br>Certaines questions sont étoilées, passez-les puis revenez-y lorsque vous aurez terminé toutes les questions non-étoilées. Il n'est pas nécessaire de répondre à toutes les questions pour obtenir une bonne note. <br>Posez des questions si vous êtes coincés. Pendant le TP ou par email.<br><br>Pour compiler votre code, vous pouvez utiliser au choix <br>
<br>Spyder
<br>N'importe quel éditeur de texte, puis compiler depuis le terminal. 
<br><br><br>Pour tracer des fonctions, on peut utiliser numpy et matplotlib. <br>Il vous suffira d'appeler la fonction suivante pour tracer un graphe:<br>import numpy as np
import matplotlib.pyplot as plt

def plot_function(f, a, b, n=100):
    x_plot = np.linspace(a, b, n) 
    # tableau de n points entre a et b
    y_plot = f(x_plot)
    plt.plot(x_plot, y_plot)
<br>En fonction de la façon dont vous compilez python, il vous faudra peut-être ajouter la ligne suivante après l'appel des fonctions : <br>plt.show()
<br>Questions :<br>
<br>Représentez le graphe de la fonction sinus (en appelant la fonction avec f = np.sin) sur l'intervalle  
<br>Que se passe-t-il si on change la valeur de n ? Testez avec n=10 et n=1000 et notez vos observations. Faudra-t-il une valeur de n plus ou moins élevée si on veut afficher un intervalle plus grand ?
<br>Vous pouvez aussi créer des fonctions à la main puis les tracer avec le code précédent. <br>def f(x):
    return x**2 - 2

plot_function(f, -1, 1)
<br>Questions :<br>
<br>Modifiez la fonction f pour tracer une parabole plus large sans changer l'abscisse du sommet. Afficher les deux paraboles sur le même graphe en appelant deux fois la fonction plot_function 
<br>** Ecrivez une fonction qui prend en paramètre une fonction , un point d'abscisse  et qui trace la tangente à la courbe de  en .
<br>Si vous avez besoin de sauvegarder un graphe, vous pouvez le faire avec la fonction savefig. <br>plt.savefig('fonctions_trigo.png')
<br><br>Pour afficher des variables ou un message dans la console, on utilise usuellement print, comme par exemple :<br>print("Bonjour")
<br>On peut mélanger du texte et des variables avec des f-strings, il suffit d'ajouter la lettre f devant les guillemets :<br>a = 5
b = 3
print(f"La somme de {a} et {b} est {a + b}")
<br>On peut aussi modifier le nombre de décimales affiché :<br>print(f"Pi avec 2 décimales : {np.pi:.2f}")
print(f"Pi avec 4 décimales : {np.pi:.4f}")
<br>ou manipuler des expressions sans avoir à les stocker dans des variables<br>a= 4.5
print(f"Le carré de {a} est {a**2}")
print(f"La racine carrée de {a} est {a**0.5:.2f}")
<br>Questions :<br>
<br>Ecrivez le code pour afficher la valeur de  en  avec 5 décimales. (vous pourrez utiliser la fonction np.expde numpy)
<br>Créez une fonction avec une boucle qui affiche la table de multiplication du nombre 7 en utilisant les f-strings.
<br>Enveloppez cette boucle dans une autre boucle pour afficher toutes les tables de multiplication de 1 à 9. 
<br><br>Au cours de ce TP, il vous sera demandé plusieurs fois de comparer des performances d'algorithmes, pour cela, vous pourrez utiliser la fonction time.time(). Par exemple :<br>import time

start_time = time.time()

### Votre fonction ###

end_time = time.time()

print(f"Temps d'évaluation : {end_time - start_time} secondes")
<br>
<br>Mesurer le temps d'exécution de votre boucle précédente qui affiche les tables de multiplication, vous pouvez augmenter le temps en affichant plus de tables de multiplications. 
<br><br>Exécutez le code suivant et observez le résultat. Qu'en pensez-vous ?<br>import math

print(f"0.1 + 0.2 = {0.1 + 0.2}") 
print(f"0.1 + 0.2 == 0.3 ? {0.1 + 0.2 == 0.3}")

print(f"(racine de 2)^2 = {math.sqrt(2)**2}")  
<br>Questions :<br>
<br>Pourquoi 0.1 + 0.2 ne donne-t-il pas exactement 0.3 ? Expliquez en 2 phrases, vous pouvez faire des recherches.
<br>Créez une boucle qui additionne 0.1 un million de fois dans une variable s, affichez le résultat théorique et la valeur obtenue.
<br>D'autres "erreurs" de calculs : <br># Avec des grands nombres :
grand_nombre = 1e16
print(f"1e16 + 1 = {grand_nombre + 1}")
print(f"1e16 + 1 == 1e16 ? {grand_nombre + 1 == grand_nombre}")

# Avec des nombres très proches
a = 1.0000000000000001
b = 1.0000000000000002
print(f"a = {a}")
print(f"b = {b}")
print(f"a == b ? {a == b}")
<br>
<br>Les trois méthodes du chapitre suivant sont itératives : elles utilisent le résultat d'un calcul comme point de départ pour le calcul suivant. A quoi faudra-t-il faire attention ? 
<br><br>Lors des premiers CM, nous avons vu 3 méthodes pour résoudre des équations de la forme . <br><br>import numpy as np
import matplotlib.pyplot as plt



def iterative_process(x0, n):
    x = np.zeros(n) # Créer un tableau de n cases rempli de 0
    
    x[0] = x0
    
    for i in range(1, n):
        x[i] = np.cos(x[i-1]) # Ligne principale
    
    return x

x0 = 0.5  
n = 50

x = iterative_process(x0, n)

plt.plot(x)
<br>Questions :<br>
<br>
Lisez, exécutez puis expliquez le code suivant. 

<br>
Examinez la ligne principale, pour quelle équation ce code essaie-t-il de trouver une solution ? 

<br>
Tracer les graphes des fonctions  et  et pointez sur le graphe la solution de l'équation. 

<br>
Testez différentes valeurs initiales x0. Observez-vous toujours la convergence ? Essayez des valeurs extrêmes. Vous pouvez toutes les tracer sur le même graphe.  

<br>
* Créez une fonction qui calcule le nombre d'itérations nécessaires pour atteindre une précision  que vous passerez en paramètre.

<br>Le code suivant compare deux suites régies par la même relation de récurrence, mais avec une légère différence dans la valeur initiale. <br>def iterative_process(x0, n):
    x = np.zeros(n)
    x_approx = np.zeros(n)
    
    x[0] = x0
    x_approx[0] = x0 + 1e-10 
    
    for i in range(1, n):
        x[i] = 30*np.cos(x[i-1])
        x_approx[i] = 30*np.cos(x_approx[i-1])
    
    return x, x_approx

x0 = 0.2  
n = 50 

x_exact, x_approx = iterative_process(x0, n)

differences = np.abs(x_exact - x_approx)

plt.semilogy(differences, label="Erreur d'approximation")
<br>Questions :<br>
<br>Quelle équation cet algorithme permet-il de résoudre ?
<br>Pourquoi la suite diverge-t-elle alors que l'algorithme précédent convergeait, qu'elle que soit la valeur initiale ? Rappelez l'hypothèse du théorème du cours utile dans ce contexte. 
<br>* Analysez la stabilité de la méthode en fonction de la valeur de la perturbation.
<br><br>Considérons la suite définie par :<br><br>Questions :<br>
<br>Vers quoi devrait converger cette suite ?
<br>La fonction  respecte-t-elle l'hypothèse du théorème ?
<br>En vous inspirant du code ci-dessus, écrivez un programme qui affiche l'évolution de la suite.
<br>* La vitesse de convergence dépend-elle fortement de la valeur initiale ? Vous pourrez illustrer votre réponse avec un graphique.
<br><br>Une autre méthode pour résoudre  est de se fixer un intervalle initial [a,b] et de découper cet intervalle en deux, en considérant uniquement la moitié qui contient la solution, puis de découper cette moitié en deux, etc ... <br>Voici le code que nous avions élaboré en cours pour résoudre l'équation  par dichotomie. <br>import math

def dichotomie(a, b, epsilon=1e-6):

	while (b - a) / 2 &gt; epsilon:
		c = (a + b) / 2
        
		if c &gt; math.cos(c):
			b = c
		else:
			a = c
    
	return (a + b) / 2 

print(dichotomie(0, 1))
<br>Questions :<br>
<br>
Modifiez la fonction pour qu'elle affiche le nombre d'itérations nécessaires.

<br>
Comparez la vitesse de convergence avec la méthode du point fixe. Vous pourrez par exemple tracer sur le même graphe les deux suites.

<br>
Créez une fonction qui trace l'évolution de l'intervalle [a,b] à chaque itération.

<br>
Utiliser la méthode de dichotomie pour trouver une valeur approchée de la solution de l'équation  à  près.

<br><br>La troisième méthode que nous avons vu en cours pour résoudre  est la méthode de Newton.<br>
<br>On part d'une valeur initiale 
<br>On calcule la tangente à la fonction  en 
<br>On regarde l'abscisse du point d'intersection de la tangente avec l'axe des abscisses
<br>On recommence avec cette abscisse. 
<br>Voici le code que nous avions élaboré en cours pour résoudre l'équation  par la méthode de Newton. <br>import math
x0 = 0.5

def f(x):
    return x - math.cos(x)

def df(x): # dérivée de f
    return 1 + math.sin(x) 

def newton(x0, epsilon=1e-6):
    x = x0
    
    while abs(f(x)) &gt; epsilon:
        x = x - f(x) / df(x) 
        
    return x

print(newton(x0))
<br>Questions :<br>
<br>Modifiez le code pour afficher le nombre d'itérations nécessaires pour atteindre la précision .
<br>Testez différentes valeurs initiales. La méthode converge-t-elle toujours ?
<br>* Que se passe-t-il si f'(x) = 0 ?
<br>* Implémentez la méthode de Newton pour trouver une valeur approchée de la solution de l'équation  à  près.
<br>* La variable epsilon correspond-elle à la précision de la valeur approchée ? Y a-t-il une différence sur cette précision entre la méthode de Newton et les deux autres méthodes précédentes ?
<br><br>Voici deux problèmes :<br>
<br>Calculer . 
<br>En reliant le nombre  à une équation sur la fonction sinus, déterminer une valeur approchée de  à  près. 
<br>
<br>* Implémentez les trois méthodes et comparez leur vitesse de convergence. Vous pourrez par exemple
<br>
<br>Un même nombre d'étapes et comparer la précision. 
<br>Mesurer le temps pour atteindre une précision fixée. 
<br>
<br>Créez un graphique montrant l'évolution de l'erreur pour chaque méthode.
<br>Analysez la stabilité numérique de chaque méthode.
<br><br>Je vous rappelle qu'un des buts principaux de notre cours est de pouvoir approcher une fonction compliquée par une fonction facile à calculer.<br>
Aussi, les polynômes sont des fonctions faciles à calculer. <br><br>On peut considérer qu'un polynôme est la liste de ses coefficients. Par exemple : <br>coefficients = [2, -6, 2, -1]  
# Correspond au polynôme 2x^3 - 6x^2 + 2x - 1
<br>Les fonctions suivantes prennent un polynôme  sous la forme d'une liste de coefficients et une abscisse  et renvoient la valeur de . <br>On peut évaluer un polynôme de manière naïve avec la fonction suivante : <br>def evaluer_polynome(coefficients, x):
    resultat = 0
    degre = len(coefficients) - 1
    for i, coeff in enumerate(coefficients):
        resultat += coeff * (x ** (degre - i))
    return resultat
<br>Nous avions aussi mentionné l'algorithme de Horner pour évaluer un polynôme de manière plus efficace : <br><br>Voici une fonction qui implémente ce calcul :<br>def evaluer_polynome_horner(coefficients, x):
    resultat = 0
    for coeff in coefficients:
        resultat = resultat * x + coeff
    return resultat
<br>Questions :<br>
<br>Générer un polynôme de degré  et un point  et mesurer le temps d'évaluation avec les deux méthodes. Vous pourrez par exemple utiliser cette fonction qui génère un tableau de 10 nombres entiers entre -5 et 5. 
<br>coeff = np.random.randint(-5, 5, 10) 
<br>
<br>Le calcul de l'image d'un polynôme en  est-il différent du calcul de l'image d'un polynôme en  ?
<br>* Tracer le graphe de polynômes aléatoires de degré différents pour illustrer le "nombre de bosses" d'un polynôme.
<br><br>Pour approcher une fonction  par un polynôme, une première idée peut être de tronquer son développement de Taylor en un point  : <br>La fonction  sur l'intervalle  approchée par son DL en 0.<br>
Le code suivant calcule les premiers termes du développement de Taylor : <br>def taylor(x, n):
	return sum((-x)**k / np.math.factorial(k) for k in range(n))
<br>Questions :<br>
<br>Pour , l'approximation obtenue est-elle satisfaisante ? 
<br>Essayez plusieurs valeurs de  pour obtenir une approximation suffisante de la fonction. 
<br>Mesurez le temps d'exécution du code pour ces valeurs de . 
<br>En écrivant une relation de récurrence entre les termes de la somme, calculez la somme de manière plus efficace. 
<br><br>Ecrivez une fonction qui prend en paramètres  points et une abscisse  et renvoie la liste des  polynômes de Lagrange  associés:<br>def lagrange(points, x):
	n = len(points)
	pols = np.zeros(n)
	for i in range(n):
		num = 1
		denom = 1
		for j in range(n):
			if i != j:
				num *= x - points[j]
				denom *= points[i] - points[j]
		pols[i] = num / denom
	return pols
<br>Questions :<br>
<br>
Que représente le tableau pols que renvoie la fonction et comment l'utiliser ? 

<br>
Ecrivez une fonction qui prend en paramètre une fonction  et une liste de points et une abscisse  et qui renvoie la valeur en  du polynôme de Lagrange qui coïncide avec  sur chaque abscisse du tableau points. 

<br>
Analysez l'erreur d'interpolation pour différentes fonctions que vous choisirez.

<br>
Comparez les résultats avec la méthode précédente qui tronque le développement de Taylor.

<br>
* Tracer le polynôme de Lagrange qui coïncide avec la fonction suivante aux points d'abscisses  . Tracer la fonction sur le même graphe, ajoutez des points pour essayer de faire coller le polynôme à la fonction.<br>


<br><br><br>Un des autres buts de ce cours est de pouvoir obtenir des valeurs approchées pour des intégrales compliquées. <br>Le code suivant implémente la méthode des rectangles à gauche pour calculer l'intégrale d'une fonction  entre  et  en l'approchant par  rectangles:<br>def integrale(f, a, b, n):
    h = (b - a) / n
    extremites = np.linspace(a, b, n+1)
    somme = 0
    for i in range(n):
        AireRectangle = f(extremites[i]) * h
        somme += AireRectangle
    return somme

print(integrale(lambda x: x**2, 0, 1, 1000))
<br>Questions :<br>
<br>Choisissez une fonction dont vous pouvez calculer l'intégrale à la main et comparez le résultat théorique avec cette méthode. 
<br>* Illustrez sur un graphe la convergence de la méthode lorsque le nombre de rectangles augmente. 
<br>* Créez une fonction qui adapte automatiquement le nombre de subdivisions pour atteindre une précision donnée.
<br><br>
<br>Implémentez la méthode des trapèzes et comparez-la avec la méthode des rectangles. Vous pourrez par exemple mesurer le temps d'exécution pour atteindre une précision donnée. 
<br>* Modifiez le code pour utiliser des subdivisions non uniformes.
<br>Analysez l'erreur en fonction du nombre de subdivisions.
<br><br>Nous avions également vu qu'on peut estimer l'intégrale d'une fonction en calculant à la place l'intégrale d'un polynôme qui approche cette fonction. Cette stratégie avait conduit à la quadrature de Newton-Cotes :<br>def newton_cotes(f, a, b):
    return (b - a) / 6 * (f(a) + 4*f((a+b)/2) + f(b))
<br>Questions :<br>
<br>
Comparez les résultats avec les méthodes précédentes.

<br>
Nous avons aussi utilisé cette formule en séparant l'intervalle d'intégration en plusieurs sous-intervalles et en appliquant cette formule sur chaque sous-intervalle. Ecrivez une fonction pour calculer l'intégrale d'une fonction avec en paramètre le nombre de sous-intervalle sur lesquels appliquer cette formule. 

<br>
Comparer les performances de cette dernière méthode avec les précédentes. 

<br>
A partir de la liste des coefficients d'un polynôme, déterminer son intégrale exacte sur un intervalle [a, b]. Utilisez cette expression pour obtenir une autre façon d'obtenir une valeur approchée d'intégrale.  

<br>
* En utilisant les fonctions précédentes, calculer des intégrales en approchant les fonctions par des polynômes de degré supérieur.

<br>
* Analysez l'erreur en fonction du degré du polynôme.

<br>
Créez une fonction qui choisit automatiquement le degré optimal du polynôme.

<br><br>Les polynômes de Hermite permettent d'obtenir un polynôme qui colle mieux à une fonction puisqu'on peut également approcher sa dérivée:<br>
Si  est le polynôme de Lagrange associé au point , on définit les polynômes<br><br>et<br><br><br>Questions :<br>
<br>Implémentez les polynômes de Hermite et testez-les sur différentes fonctions.
<br>Comparez les résultats avec l'interpolation de Lagrange.
<br>Analysez l'erreur d'interpolation pour différentes fonctions.
<br>Créez une fonction qui combine interpolation et dérivées pour obtenir une meilleure approximation. 
<br>Ecrivez un programme qui calcule l'intégrale d'une fonction  en se basant sur les polynômes de Hermite. 
]]></description><link>enseignement/4-analyse-numérique/tp-1-analyse-numérique.html</link><guid isPermaLink="false">Enseignement/4 - Analyse Numérique/TP 1 Analyse Numérique.md</guid><pubDate>Thu, 22 May 2025 08:01:20 GMT</pubDate></item><item><title><![CDATA[TP 2 Analyse Numérique]]></title><description><![CDATA[ 
 <br>La version interactive de ce TP se trouve ici :  <a data-tooltip-position="top" aria-label="https://maximeberger.github.io/Analyse_Numerique/enseignement/4-analyse-num%C3%A9rique/tp-2-analyse-num%C3%A9rique.html" rel="noopener nofollow" class="external-link" href="https://maximeberger.github.io/Analyse_Numerique/enseignement/4-analyse-num%C3%A9rique/tp-2-analyse-num%C3%A9rique.html" target="_blank">ce lien</a><br>Cette version interactive vous permettra de copier-coller le code python plus facilement !<br>Thèmes: <br>
Décomposition LU, Systèmes linéaires, inverse de matrices, Equations différentielles. Application
<br><br>Vous rendrez A la fin de la séance votre rapport en déposant votre fichier sur ce lien :  <a data-tooltip-position="top" aria-label="https://www.dropbox.com/request/AnYEHDuv6kPmB1CkVef3" rel="noopener nofollow" class="external-link" href="https://www.dropbox.com/request/AnYEHDuv6kPmB1CkVef3" target="_blank">Dépôt TP2</a><br>
Si vous le souhaitez, vous pouvez poursuivre le travail chez vous et rendre un rapport amélioré avant le 1er juin 23h59. Votre note sera augmentée d'un maximum de 5 points<br>L’utilisation d’outils comme ChatGPT ou Copilot est autorisée pour apprendre, mais toute production de texte/code générée doit être reformulée ou réécrite personnellement dans le rapport final.<br>
<br>Soupçons -&gt; Division de la note par 2
<br>Certitude -&gt; 0/20
<br>Vous rendrez un rapport de TP avec <br>
<br>les réponses aux questions, 
<br>les parties de code que vous avez modifiées ou écrites en les expliquant, 
<br>les graphiques que vous avez générés<br>
Vous reprendrez la structure de ce sujet avec les titres et les sous-titres. 
<br>Vous pouvez travailler seul ou par binôme.<br><br>Nous avions établi en TD l'algorithme suivant pour obtenir la décomposition LU d'une matrice<br>import numpy as np

def DecomposeLU(A):
	n = len(A)
	L = np.eye(n) # Matrice identité
	U = np.zeros((n,n)) # Matrice nulle
	
	for i in range(n):
		# Calcul de la i-ème ligne de U
		for j in range(i, n):
			U[i,j] = A[i,j] - sum(L[i,k] * U[k,j] for k in range(i))
		# Calcul de la i-ème colonne de L
		for j in range(i+1, n):
			L[j,i] = (A[j,i] - sum(L[j,k] * U[k,i] for k in range(i))) / U[i,i]
		
	
	return L, U
<br>Prenons la matrice <br><br>qui peut s'écrire en python<br>A = np.array([[1, 1, 2], [1, 2, 1], [2, 1, 1]])
<br>
<br>Vérifiez que la décomposition LU que nous avions calculée au TD 2 est correcte :<br>

<br>La décomposition  d'une matrice  est :
<br><br>Faites calculer la matrice  à python, puis recalculer  et . Obtient-on bien le même résultat ?<br>
Pour faire un produit matriciel, on utilise A @ B avec l’opérateur @, qui réalise le produit matriciel.<br>* Formez une matrice carrée aléatoire de taille  pour commencer. Mesurez le temps pour calculer la décomposition LU de cette matrice. Si vous êtes à l'aise, vous pourrez tracer le temps mis par la fonction en fonction de . <br>Pour générer une grande matrice aléatoire, on peut par exemple utiliser : <br>import random

n = 100
M = []
for i in range(n):
    L = []
    for j in range(n):
        L.append(random.randint(-5, 5))
    M.append(L)
<br>
Il existe des outils pour visualiser de grandes matrices en python, essayez par exemple 
<br>matplotlib.pyplot.imshow(A)
<br><br>En TD, nous avons utilisé la décomposition LU pour ramener tout système linéaire à des systèmes triangulaires. <br>Commençons donc par essayer de résoudre des systèmes triangulaires :<br>Si  est une matrice triangulaire supérieure, le système s'écrit<br><br>Pour résoudre ce genre de système, on commence par la dernière ligne puis on remonte les calculs : <br><br>Pour résoudre un système triangulaire supérieur, on peut donc utiliser :<br>def SolveTriSup(U, b):
	n = len(U)
	x = np.zeros(n)
	for i in range(n-1, -1, -1):
		x[i] = (b[i] - sum(U[i,j] * x[j] for j in range(i+1, n))) / U[i,i]
	return x
<br>
<br>
Ecrivez une fonction similaire SolveTriInf(L, b) pour résoudre un système triangulaire inférieur

<br>
Ecrivez une fonction python Resoudre(A, b) qui donne la solution du système linéaire  ( la fonction contient 3 lignes de code. )

<br>Reprenons la matrice  dont la décomposition   est :<br><br>
<br>
Résoudre le système  avec le vecteur .

<br>
Afficher la solution du système linéaire  avec 

Faite de même si maintenant Qu'en pensez-vous ?

<br><br>La décomposition LU permet aussi de calculer l'inverse d'une matrice. <br>Pour calculer l'inverse, on peut utiliser le programme suivant <br>def Inverse(A):
	L, U = DecomposeLU(A)
	n = len(A)
	N = np.zeros((n,n))
	M = np.zeros((n,n)) 
	for i in range(n):
		b = np.zeros(n)
		b[i] = 1 # b est la i-ième colonne de la matrice identité
		N[:,i] = SolveTriInf(L, b)
		M[:,i] = SolveTriSup(U, N[:,i]) # M est la matrice inverse de A
	return M```

7. Comparer la vitesse pour résoudre un système linéaire en calculant l'inverse ou en résolvant les deux systèmes triangulaires. Vous pourrez prendre de grandes matrices aléatoires. 

8. Reprenez l'exemple précédent avec $AX=Y$. Calculez $A^{-1}$ et expliquez le comportement de la question 6.  

# \*Méthode de Jacobi : 
Si vous n'êtes pas en avance, vous pouvez passer cette partie. 

La méthode de Jacobi permet d'obtenir des solutions approchées d'un système avec une méthode itérative. 

```python
def Jacobi(A, b, x0, tol=1e-6, max_iter=100):
	n = len(A)
	x = x0
	for k in range(max_iter):
		x_new = np.zeros(n)
		for i in range(n):
			x_new[i] = (b[i] - sum(A[i,j] * x[j] for j in range(n) if j != i)) / A[i,i]
		if np.linalg.norm(x_new - x) &lt; tol:
			return x_new
<br>
<br>
Ecrivez une fonction qui calcule la distance entre deux vecteurs et tracer la distance entre les points intermédiaires de la méthode et la solution du système : 


<br>
Comparer la vitesse de la méthode Jacobi avec les méthodes de résolutions exactes des sections précédentes. Pour vous assurer de la convergence de la méthode de Jacobi, vous pourrez ajouter  à une grande matrice aléatoire. 

<br><br>On cherche à casser une règle en plastique en la pliantde 30 cm.<br>
On note y(x) le déplacement transversal positif vers la droite.<br>
<img alt="Capture d’écran 2025-02-03 à 14.20.25.png" src="lib/media/capture-d’écran-2025-02-03-à-14.20.25.png" style="width: 450px; max-width: 100%;"><br>L'équation différentielle est compliquée et fait intervenir le module d'Young et le moment d'inertie: les propriétés physiques d'une règle en plastique sont les suivantes :<br><br>Pour le moment d'Inertie, on modélise la section comme un rectangle :<br>
•	largeur (sens de lecture) <br>
•	épaisseur <br>a) Flexion dans le sens de la largeur, la règle est posée debout sur le sol, on la fait plier<br><br>b) Flexion “de tranche”, la règle est couchée sur sa tranche.<br><br>On exerce sur la règle une force verticale . <br>
<br>A la main, de quel ordre de grandeur est la force que vous pouvez appliquer (en Newton) ? 
<br>Les rotations aux appuis sont libres : .<br>L'équation différentielle qui gouverne le déplacement est de la forme<br>
<br>Pour trouver le moment où la règle va casser, on cherche une solution de l'équation en annulant le second membre. Nous nous intéressons donc à l'équation<br>
En posant , l'équation s'écrit aussi :<br>
12. A l'aide des conditions aux limites, déterminer l'expression de  et la plus petite force de flambage qui fait casser la règle. <br>Nous allons faire tracer à l'ordinateur la solution de cette équation. On découpe la règle en  segments à l’aide de  points <br>
<br>Donner la formule du pas spatial  et écrivez en python le tableau sommets qui contient les abscisses des points. 
<br>À l’aide de la différence centrée d’ordre 2,<br>
on peut simplifier l'équation différentielle :<br>
14. Au brouillon, commencez par écrire les expressions obtenues pour  puis généralisez. Écrire les équations pour chacun des noeuds, en remarquant que<br>
Ecrivez la collection d’équations sous la forme matricielle<br>
15. Formez en python la matrice  puis utilisez les outils de la première section pour tracer la solution . Vous pourrez augmenter le nombre de segments pour obtenir une solution plus lisse. ]]></description><link>enseignement/4-analyse-numérique/tp-2-analyse-numérique.html</link><guid isPermaLink="false">Enseignement/4 - Analyse Numérique/TP 2 Analyse Numérique.md</guid><pubDate>Fri, 23 May 2025 06:32:00 GMT</pubDate><enclosure url="lib/media/capture-d’écran-2025-02-03-à-14.20.25.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/capture-d’écran-2025-02-03-à-14.20.25.png&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>